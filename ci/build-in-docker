#!/bin/bash

#
# Builds container image and extracts specific artifact outside
# Notice, it does not use volume mounts, and this is on purpose.
# This way it encourages images to be self contained
# including everything needed for the build
#
# usage: build-in-docker <image-preffix> <artifact-source> <artifact-destination>
#

set -o nounset -o errexit

# takes input to this script
prefix=$1
src_path=$2
dst_path=$3
timestamp=$(date +%s)

# combine image/container names
base_container=${prefix}-container
image=${prefix}-${timestamp}-img
container=${prefix}-${timestamp}-cont

# Builds here (if fails then no image is here = nothing to clean up)
docker build --tag ${image} --file Dockerfile .

# rm -fr ${dst_path}
# rm -fr ${dst_path}

# this can fail due to 
if docker run --rm --detach --name ${container} \
      --entrypoint=/usr/bin/tail \
      ${image} -f /dev/null
then
  echo "ðŸ’š Docker container started successfully"
else
  echo "ðŸ’” Error starting Docker container"
  exit_status=$?
  docker stop ${container} || true
  docker rm ${container} || true
  docker rmi ${image}
  exit $exit_status
fi

# This can fail due to misconf, and needs cleanup
if docker cp ${container}:${src_path} ${dst_path}; then
  echo "ðŸ’š File copied successfully"
else
  echo "ðŸ’” Error copying file"
  exit_status=$?
  docker stop ${container} || true
  docker rm ${container} || true
  docker rmi ${image}
  exit $exit_status
fi

docker stop ${container} || true
docker rm ${container} || true
docker rmi ${image}

ls -las "$(pwd)/"
ls -las "$(pwd)/${dst_path}"